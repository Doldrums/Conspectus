/* Префикс-функция PI для строки S - массив максимальных длинн равных префиксов строки S и символа S[i]
 * 
 * S = "abcabcd"
 * Pi[0] = 0 | "a"       | Условие выполняется всегдавсегда
 * Pi[1] = 0 | "ab"
 * Pi[2] = 0 | "abc"
 * Pi[3] = 1 | "abca"    | Перфикс "a": "AbcA"
 * Pi[4] = 2 | "abcab"   | Префикс "ab": "ABcAB"
 * Pi[5] = 3 | "abcabc"  | Префикс "abc": "ABCABC"
 * Pi[6] = 0 | "abcabcd" | Префикса нет
 */

/* Задачи, решаемые алгоритмом:
 * - Нахождение вхождений образа T в строку S (количество и их места) 
 *   алгоритмом Кнута-Морриса-Пратта
 * - Сжатие строки путем нахождения циклически-повторяющегося фрагмента
 * 
 */

/* Алгоритм нахождения префикс-функции
 * Память:   O(n) | Массив, хранящий значения функции для строки длинны n
 * Скорость: O(n)
*/
std::vector<int> prefix_function(std::string s) {
    int n = s.length();
    std::vector<int> pi(n);
    pi[0] = 0; // Префикс-функция первого символа всегда равна нулю

    for (int i = 1, j = 0; i < n; i++) {
        // i - указатель на текущий символ строки
        // j - указатель на текущий рассматриваемый символ в префиксе
        while (j > 0 && s[i] != s[j])
            j = pi[j - 1]; // При ненулевом j и неравных s[i] и s[j] возвращаемся к предыдущему месту сохранения префикс-свойств

        if (s[i] == s[j]) {
            j++;
            pi[i] = j; // Если символы равны - отмечаем эту равность в префкс-функции и идем далее
        } else {
            pi[i] = 0; // Рассматриваемый символ не равен первому символу префикса
        }
    }

    return pi;
}

/* Алгоритм Кнута-Морриса-Платта - алогоритм поиска вхождений образа T в строку S.
 * Схож с наивным алгоритмом, но для отката назад использует префиксное дерево, благодаря чему
 * производятся не полные проверки вхождения, что экономит время
 * Память: O(|T|) | Память требуется для хранения префикс-функции образа T
 * Скорость: O(|T| + |S|)
 * 
 * Вход: S - строка, в которой производится поиск; 
 *       T - образ, вхождения которого требуется найти
 * Выход: массив индексов вхождения T в S
*/
std::vector<size_t> kmp(std::string s, std::string t) {
    vector<size_t> entries; // Массив, в котором хранятся индексы вхождений
    vector<int> pi = prefix_function(t); // Находим префикс-функцию от образе T
    // Примечание: entries не участвует в оценке памяти, так как является побочным
    // продуктом нашей обработки, и непосредственно в алгоритм КМП не входит

    for (size_t i = 0, j = 0; i < s.length(); i++) {
        // i - указатель на рассматриваемый символ в строке S
        // j - указатель на рассматриваемый символ в образе T
        while (j > 0 && s[i] != t[j])
            j = pi[j - 1];

        if (s[i] == t[j])
            j++;

        if (j == t.length()) {
            // Если индекс j равен длинне T, то найдено вхождение
            // Производится обработка этого случая
            entries.push_back(i - j + 1);

            j = pi[j - 1];
            // Откатываем j к предедущей части префикса, чтобы найти
            // такую подстроку, которая частично входит в предыдущее вхождение
        }
    }
    return entries;
}

/* Алгоритм Кнута-Морриса-Платта, версия с конкатенацией строк
 * Образец склеивается со строкой через разделитель, не входящий ни в одну строку,
 * например: T + # + S = aba#ababbababa. От этой строки находится префиксная функция Pi,
 * которая не может превышать значение 3, так как # не входит в S.
 * Таким образом достаточно найти такие значения Pi[i] при i > |T|+1, которые равны |T|.
 */
std::vector<size_t> kmp2(std::string s, std::string t) {
    size_t tl = t.length();
    vector<size_t> ans; // Массив, в котором хранятся индексы вхождений T в S
    vector<int> pi = prefix_function(t + "#" + s); // Находим префкис-функцию
    for (size_t i = 0; i < s.length(); i++)
        if (pi[tl + 1 + i] == tl)
            ans.push_back(i - tl + 1);
    return ans;
}

/* Сжатие строки
 * Рассмотрим префикс-функцию строки S = "abcabcabc":
 * Str: a b c a b c a b c
 * Pi:  0 0 0 1 2 3 4 5 6 
 * Видно, что мы можем сократить 6 символов до строки "abc" * 3. Ее длинна: k = n - pi[n - 1] // 9 - 6 = 3
 * Если длинна строки делится на k, то строка делится на (n / k) частей длинны k.
 * Следовательно, искомой подстрокой является S[0..k].
 * Иначе, строка не сокращается, ответом является 1 часть длинной n.
 * 
 * Вход: строка S
 * Выход: {длинна подпрефикса, количество частей}
 */
std::pair<int, int> compress_string(string s) {
    size_t n = s.length();
    vector<int> pi = prefix_function(s);
    int k = n - pi[n - 1];
    if (n % k == 0)
        return {k, n / k};
    else
        return {n, 1};
}
