/* Z-функция строки S - это массив наибольших длинн префикса S и префикса, начинающегося в i-й позиции
 * 
 * Например, S = "abacaba" (n = 7):
 * z[0] = 0|7 | Значение функции в позиции 0 не определено, его принято обозначать 0 или n;
 * z[1] = 0 | "abacaba"
 * z[2] = 1 | "AbAcaba"
 * z[3] = 0 | "abacaba"
 * z[4] = 3 | "ABAcABA"
 * z[5] = 0 | "abacaba"
 * z[6] = 0 | "AbacabA"
 */
/* Алгоритм нахождения Z-функции
 * Память: O(n)
 * Скорость: O(n)
 * 
 * Для ускорения работы в раммках рассматриваемой строки устанавливаются границы L и R - начало и
 * конец последнего наибольшего префикса.
 * 
 * Таким образом, задача сводится к двум случаям:
 * - i <= r: в таком случае берется min(r - i + 1, z[i - l]):
 *      Так как S[0..r - l] == A[l..r] (как только что рассматриваемые подстроки), то мы можем
 *      предварительно установить z[i] = z[i - l], т.к. очевидно, что l <= i <= r.
 *      Благодаря выбору минимального исключается случай, когда значение z[i - l] превосходит
 *      количество оставшихся в строке не обработанных символов.
 * - i > r: в таком случае z[i] устанавливается простым перебором, после чего передвигаются
 *      значения l в позицию i и r в позицию i + z[i] - 1.
 * 
 * Таски с тестами:
 * - Informatics msk (96 тестов, в т.ч. крайние): https://informatics.msk.ru/mod/statements/view3.php?id=241&chapterid=1324
 */
std::vector<int> z_function(std::string s) {
    std::vector<int> z(s.length());
    z[0] = s.length();
    for (int i = 1, l = 0, r = 0) {
        if (i <= r)
            z[i] = min(r - i + 1, z[i - l]);
        while (i + z[i] < s.length() && s[z[i]] == s[i + z[i]])
            z[i]++;
        if (i + z[i] - 1 > r)
        {
            l = i;
            r = i + z[i] - 1;
        }
    }

    return z;
}

/* Нахождение вхождений образа T в строку S по Z-функции
 * Например, S = "ababbababa", T = "aba". Объединим их в X = T + "#" + S и найдем Z-функцию:
 *   a  b a # a b a b b a b a b a
 *   14 0 1 0 3 0 2 0 0 3 0 3 0 1 
 * Можно заметить, что максимальное значение Z-функции, по аналогии с префикс-функцией - 3,
 * так как знак "#" отсутствует в алфавитах строк S и T. Таким образом, если Z функция равна
 * 3-м, то с этого знака начинается вхождение образа T в строку S.
 * 
 * Таски для проверки корректности:
 * - Informatics MSK: https://informatics.msk.ru/mod/statements/view3.php?id=241&chapterid=99#1
 */
std::vector<size_t> find_entries(std::string s, std::string t) {
    std::vector<size_t> entries;
    std::vector<int> z = z_function(t + "#" + s);
    for (int i = 0; i < s.length(); i++) {
        if (z[t.length() + 1 + i] == t.length())
            entries.push_back(i);
    }
    return entries;
}

/* Задача сжатия строки через Z-функцию
 * Пусть дана строка: "abcabcabc". Найдем ее Z-функцию:
 * a b c a b c a b c
 * 9 0 0 6 0 0 3 0 0
 * Если строку можно сжать, то циклично Z-функция будет принимать значение, равное n - i.
 * Таким образом, если i + z[i] == n, тогда можно сказать, что строку можно сократить до
 * "abc" * i.
 * 
 * Вывод: {длинна, количество частей}
 */
std::pair<int, int> compress_string_z(string s) {
    std::vector<int> z = z_function(s);
    int n = s.length();
    int i;
    for (i = 1; i < s.length(); i++) {
        if (i + z[i] == n && n % i == 0)
            break;
    }
    return {i, n / i};
}